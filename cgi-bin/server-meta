#! /usr/bin/perl -T
use strict;
use warnings;
use English qw(-no_match_vars $INPUT_RECORD_SEPARATOR);
use YAML::Loader;
use YAML 'Dump';

use Try::Tiny;
use File::Slurp qw( slurp read_dir );
use Sys::Hostname 'hostname';
use Time::HiRes qw( tv_interval gettimeofday );
use File::Find;


=head1 NAME

cgi-bin/server-meta - return info about webserver(s)

=head1 DESCRIPTION

This script emits in YAML the set of webserver hosts configured by the
webteam.  The purpose is to avoid relying on a stale copy of the list.

=cut

my ($ROOT_PATH, $service_key);
my $WEBDIR;
sub main {
    $ROOT_PATH = '/www/utilities'; # will only work on webteam VMs
    $service_key = 'otter';

    $WEBDIR = $0;
    $WEBDIR =~ s{/cgi-bin/.*}{} or die "Can't make webdir from $0";

    $ENV{PATH} = '/bin:/usr/bin';

    # Guard for overload
    my @load = (split /\s+/, slurp('/proc/loadavg'))[0,1,2]; # 1min, 5min, 15min
    if (grep { $_ >= 2 } @load) {
        print "Status: 503 Service Unavailable\nContent-type: text/plain\n\nToo busy\n";
        print Dump({ load => \@load });
        return 0;
    }

    # Generate details
    my $t0 = [ gettimeofday() ];
    my %out =
      (svn_config => (try { config_extract( get_configuration() ) } catch { "ERR:$_" }),
       load => \@load,
       webdir => $WEBDIR,
       t0 => $^T,
      );

    if ($ENV{QUERY_STRING} eq 'detail') {
        $out{instances} = servers_here();
        $out{repos} = git_detail($WEBDIR);
        $out{otters} = otters_detail($WEBDIR);
    }
    $out{t_run} = tv_interval($t0);

    print "Content-type: text/plain\n\n".
      "Give ?detail for extra info.\n";
    print Dump(\%out);

    return 0;
}


sub get_configuration { # based on /www/utilities/restricted-scp v196
  my $contents;
  if( open my $fh, q(<), "$ROOT_PATH/config/scp.yaml" ) {
    local $INPUT_RECORD_SEPARATOR = undef;
    $contents = <$fh>;
    close $fh; ## no critic (RequireChecked)
  } else {
    die "Unable to read YAML file\n";
  }
  my $yl   = YAML::Loader->new;
  my $raw_config = $yl->load( $contents );
  die "Unable to parse YAML file\n" unless $raw_config;
  return $raw_config;
}


sub config_extract { # by inspection of /www/utilities/config/scp.yaml v195
    my ($cfg) = @_;
    my @out;
    die "No useful config found" unless $cfg->{$service_key}{live};
    while (my ($k, $v) = each %{ $cfg->{$service_key} }) {
        my @servers = @{ $v->{servers} }
          or die "No servers in '$k'";
        my %paths = %{ $v->{paths} }
          or die "No paths in '$k'";
        my %rw = reverse %paths;
        die "Confused by paths - need (read, write)"
          unless 2 == keys %paths && 2 == keys %rw;

        push @out, map {
            +{ type => $k, hostname => $_,
               write => $rw{write}, read => $rw{read} }
        } @servers;
    }

    return \@out;
}


sub servers_here {
    # List procs
    my $pid = open my $fh, '-|', ('ps', '-eo', 'pid,ppid,user,cmd')
      or die "Pipe from ps failed: $!";
    my @ln = <$fh>;
    close $fh
      or die "Pipe from ps closed: $! / $?";
    foreach (@ln) { s/^\s+|\s+$//g }
    my @hdr = split /\s+/, shift @ln;
    my @proc = map {[ split /\s+/, $_, scalar @hdr ]} @ln;

    # Find Apache process groups in our style
    my $webvm_style =
      qr{
            ^/\S*/s?bin/(?:apache2|httpd)\b # webserver
            .*\s+(?:-f\s*)?                 # space or config mark
            (/[-_.a-zA-Z0-9/]+)             # capture directory part = webdir
            /ServerRoot/conf/httpd\.conf\b  # webvm-style config
    }x;
    my @webvm # [ pid, ppid, user, cmd, webdir ]
      = map { $_->[3] =~ $webvm_style ? ([ @$_, $1 ]) : () } @proc;

    # Exclude child processes
    my %pid;
    @pid{ map { $_->[0] } @webvm } = ();
    @webvm = grep { !exists $pid{ $_->[1] } } @webvm;

    # Get details
    @webvm = map { instance_detail(@$_) } @webvm;

    return \@webvm
}


sub instance_detail {
    my ($pid, undef, $user, $cmd, $webdir) = @_;

    # Look up port number
    my $fn = "$webdir/ServerRoot/conf/user/$user.conf";
    die "webvm.git config assumptions turned out to be broken" unless -f $fn;
    my @ucfg = slurp($fn);
    my @port = map { m{^Listen\s+(\d+)\s*$} ? ($1) : () } @ucfg;
    die "Can't get port for $user in $webdir" unless 1 == @port;

    my %out =
      (user => $user, pid => $pid, cmd => $cmd,
       hostname => hostname(),
       webdir => $webdir, port => $port[0]);
    $out{self} = 1 if $user eq getpwuid($<) && $webdir eq $WEBDIR;

    return \%out;
}


sub git_detail {
    my ($webdir) = @_;

    # Find Git repositories
    my %repo;
    find({ wanted => fffilter($webdir, \%repo),
           no_chdir => 1,
           follow => 1,
           follow_skip => 2,
         }, $webdir);

    return \%repo;
}


sub fffilter {
    my ($webdir, $repo_hash) = @_;
    return sub { # File::Find "wanted" filter
        # pathname is in $_; an lstat($_) has happened
        return unless -d _; # not interested in files
        if (m{^(.*)/\.git$}) {
            # looks enough like a Git working copy
            my $repo = $1;
            $repo_hash->{$repo}{describe} = _repo_detail
              ($repo, qw( git describe --tags --long --always --abbrev=8 --dirty ));
            $repo_hash->{$repo}{status} = _repo_detail($repo, qw( git status ));
            $File::Find::prune = 1;
        } elsif (m{/ensembl\d+$}) {
            # huge tree, not expected to contain interesting stuff
            $File::Find::prune = 1;
        }
        # else carry on filtering...
        return;
    };
}

sub _repo_detail {
    my ($repo_dir, @cmd) = @_;

    my $pid = open my $fh, '-|';
    if (!defined $pid) {
        die "pipe from fork failed: $!";
    } elsif (!$pid) {
        # child
        open STDERR, '>&', \*STDOUT or die "Dup: $!";
        chdir $repo_dir or die "chdir $repo_dir: $!";
        exec @cmd;
        die "exec @cmd: $!";
    } # else parent
    my $out = do { local $/; <$fh> };
    chomp $out;
    close $fh or die "piped from @cmd[0,1] $repo_dir: failed $! / $? / $out";

    return $out;
}


sub otters_detail {
    my ($webdir) = @_;

    my $cgi = "$webdir/cgi-bin/otter";
    my @num = read_dir($cgi);
    my %out;
    @out{@num} = map { -f "$cgi/$_/test" && -x _ } @num;

    return \%out;
}


exit main();
